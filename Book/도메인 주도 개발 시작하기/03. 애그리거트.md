# 애그리거트

### 애그리거트

- 애그리거트 단위로 묶는다면 복잡한 모델을 관리한느 기준을 제공한다.
- 모델을 이해하는데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다.
- 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많고, 두 개 이상의 엔티티로 구성되는 애그리거트는 드물다.

### 애그리거트 루트

- 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
- 애그리거트 전체를 관리할 주체가 필요한데 이 책임을 가지는 것이 애그리거트의 루트 엔티티이다.
- 예) 주문 애그리거트 → Order → OrderLine, ShippingInfo, Orderer
    - 애그리거트에 속한 모델은 직간접적으로 속한다.

### 트랜잭션과 애그리거트의 수정

- 한 트랜잭션에서는 한 애그리거트만 수정해야 한다.
- 다음과 같은 경우에는 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.
    - 팀 표준, 기술적 제약(이벤트 방식을 도입할 수 없는 경우)
    - UI 구현의 편리(여러 주문의 상태를 한 번에 변경할 때)
    

### 리포지토리와 애그리거트

- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.
- 애그리거트의 상태가 변경된다면 모든 변경을 원자적으로 저장소에 반영해야 한다.

### ID를 이용한 애그리거트 참조

- 필드를 이용해 다른 애그리거트를 직접 참조하는 것은 구현의 편리함을 제공하지만 다음 문제를 야기할 수 있다.
    - 편한 탐색 오용
    - 성능에 대한 고민
        - Lazy Eager
    - 확장 어려움
- 이에 대한 문제 해결방법으로 ID를 이용한 참조를 할 수 있다.
- 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.
- 애그리거트간 경계를 명확히하고 물리적인 연결을 제거한다.
- 애그리거트 별 다른 구현 기술을 사용하는 것도 가능하다.
    - 중요 데이터는 RDBMS에, 조회 성능이 중요한 것은 NoSQL
- ID 참조 방식을 사용할 때 N + 1 조회가 같은 문제가 발생하지 않도록 하려면 조회 전용 쿼리를 사용하라
    - 조회 전용 DAO 구현

### 애그리거트간 집합 연관

- 카테고리와 상품의 경우 모든 연관관계를 조회하지 않고 페이징을 이용할 수 있다.
- 프로덕트가 수만개로 많다면 성능에 문제가 일어날 수 있다.
- 특정 카테고리에 속한 상품 목록을 보여줄 때 각 상품이 속한 모든 카테고리를 상품 정보에 표시하지는 않는다. 따라서 카테고리에서 상품으로의 집합 연관은 필요하지 않고, 카테고리로의 집합 연관만 존재하면 된다. 개념적으로는 상품과 카테로기 양방향 M-N 연관이지만 실제 구현에서는 단방향 M-N이다.

### 애그리거트를 팩토리로 사용

- 예) 특정 상점이 신고당해서 물건을 등록하지 못하도록 차단했을 때, 상품 등록 기능의 구현
- Service에서 구현할 수 도 있지만 Store에서 Product를 생성하는 팩토리 역할을 할 수 도 있다.
- Store에서 생성할 때 알아야하는 정보가 많은 경우 Product 애그리거트를 직접 생성하지 않고 다른 팩토리에 위임하는 방법도 있다.