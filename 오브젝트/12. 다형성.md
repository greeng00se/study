> 오브젝트를 읽고 정리한 글입니다.
>

### 다형성이란 무엇인가?

- 많은 형태를 가질수 있는 능력
- 하나의 추상 인터페이스에 대해 코드를 작성하고, 서로 다른 구현을 연결할 수 있는 능력

### 다형성의 분류

- 유니버설 다형성(Universal)
    - 매개변수(Parametric) → 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의로 지정하고 사용 시점에 구체적인 타입으로 지정하는 방식, `List`를 생각?
    - 포함(Inclusion) → 메시지가 동일하더라도 수신한 객체의 타입에 따라 수행하는 행동이 달라지는 것
- 임시 다형성(Ad Hoc)
    - 오버로딩(OVerloading) → 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
    - 강제(Coercion) → 언어가 지원하는 자동적인 타입 변환, 사용자가 직접 구현한 타입 변환

12장에서는 포함 다형성에 관해 다룬다.

포함 다형성을 구현하는 방법은 상속을 사용하는 것이다.

상속 관계로 연결하고, 오버라이드 후 클라이언트가 부모 클래스만 참조하면 된다.

### 데이터 관점, 행동 관점에서의 상속

- 데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 볼 수 있다.
- 행동 관점에서 상속은 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미한다.

### 객체지향 시스템의 메서드 선택 방법

- 메시지를 수신한 객체는 자신이 생성한 클래스에 적합한 메서드가 존재하는지 검사한다.
    - 존재한다면 메서드를 실행하고 탐색을 종료한다.
- 메서드를 찾지 못했다면 부모 클래스에서 메서드 탐색을 진행하며, 이 과정은 적합한 메서드를 찾을 때 까지 상속 계층을 따라가며 계속된다.
- 최상위 클래스에서도 메서드를 발견하지 못하는 경우 탐색을 중단한다.
- 메서드 탐색은 두 가지 원리로 구성된다.
    - 자동적인 메시지 위임 → 클래스 사이의 위임은 상속 계층을 따라 자동으로 이뤄짐
    - 동적인 문맥 사용 → 어떤 메서드를 실행할 지 실행 시점에 결정

### self와 super

- self 참조
    - 메시지를 수신한 객체에 따라 메시지 탐색을 위한 문맥이 동적으로 결정된다.
    - 동적으로 문맥을 결정하기 때문에 자기 자신의 메서드를 호출하는 경우 어떤 메서드가 실행될지 예상하기 어려워 진다.(이펙티브 자바 아이템 18의 self-use)
        - 깊은 상속 계층 + 계층 중간에 포함되어있는 메서드 오버라이딩 + 자기 사용 여부
- super 참조
    - 부모 클래스의 구현을 재사용할 때 사용되며 부모 클래스에서부터 메서드 탐색이 진행된다.

### 위임

- 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것
- 위임은 객체의 동적인 연결 관계를 이용해 상속을 구현하는 방법이다.
    - 이는 루비로 구현된 책의 예시인 메시지 전달 과정을 보면 더욱 쉽게 이해할 수 있다.
- 상속은 복잡한 위임 과정을 자동으로 처리해준다.

### 용어 정리

- 메서드 오버라이딩 → 자식 클래스 안에 상속받은 메서드와 동일한 시그니처 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것
- 메서드 오버로딩 → 부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것
- 업캐스팅 → 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것
- 동적 메서드 탐색 → 상속 계층을 따라 동적으로 메서드를 찾는 것
- 동적 바인딩 → 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정되는 것
- self 참조 → 메시지를 수신한 객체의 클래스에 따라 메서드 탐색을 위한 문맥을 실행 시점에 결정한다.
- super 참조 → 부모 클래스부터 메서드 탐색을 시작한다.