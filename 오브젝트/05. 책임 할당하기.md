> 오브젝트를 읽고 정리한 글입니다.
> 

### 개요

- 일반적인 책임할당을 위한 소프트웨어 패턴(GRASP)을 참고해 책임 할당에 대한 기준 알아보기

### GRASP(General Responsibility Assignment Software Pattern)

- 크레이그 라만의 Applying UML and Patterns이라는 책에서 나온 책임 할당을 위한 패턴

### 정보 전문가 패턴(Infomation Expert)

- 문제 → 객체에 책임을 할당하는 기본 원칙은?
- 해결 → 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당한다.
- 정보와 행동을 가까운 곳에 위치시키기 때문에 캡슐화를 유지할 수 있다.
- 필요한 정보를 가진 객체들로 책임이 분산된다.

### 낮은 결합도 패턴(Low Coupling)

- 문제 → 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시키는 방법은?
- 해결 → 전체적인 결합이 낮게 유지되도록 책임을 할당해야 한다.
- 예) 결합도 관점에서 상영 클래스와 영화 클래스 중 할인조건과 협력은 누가해야 할까?
    - 도메인 상으로 이미 영화 클래스와 할인 조건이 결합되어 있다.
    - 이 때 상영 클래스와 할인조건이 협력하게 된다면 새로운 결합도가 추가된다.
    - 따라서 영화 클래스와 할인 조건의 협력이 더 나은 설계 대안이다.

### 높은 응집도 패턴(High Cohesion)

- 문제 → 객체를 관리하기 쉽게 하려면 어떻게 해야할까?
- 해결 → 높은 응집도를 유지할 수 있게 책임을 할당해야 한다.
- 예) 응집도 관점에서도 영화 클래스와 할인 조건의 협력이 더 나은 대안이다.
    - 상영 클래스의 중요 책임은 예매 생성이다. 하지만 할인 조건과 협력한다면 요금 계산에 대한 책임을 일부 가지게 된다.
    - 이 경우 요금 계산에 대한 내용이 변경된다면 상영 클래스도 일부 변경될 수 있다.
    - 하지만 영화 클래스의 경우 주된 책임이 요금 계산에 대한 내용이기 때문에 할인 조건과 협력하는 것이 합당하다.

### 창조자 패턴(Creator)

- 문제 → 누가 객체 A를 생성하는가?
- 해결 → 다음의 조건을 최대한 많이 만족하는 객체에게 객체 생성 책임을 할당해야 한다.
    - B가 A 객체를 포함 또는 참조한다.
    - B가 A 객체를 기록한다.
    - B가 A를 긴밀하게 사용한다.
    - B가 A의 초기값을 가지고 있다.
- 예) 영화 예매 협력의 최종 결과물은 예매 인스턴스 생성이다.
    - 예매에 관해 가장 많은 정보를 알고 있는 상영 클래스가 예매를 생성한다.

### 다형성 패턴(Polymorphism)

- 문제 → 객체의 타입에 따라 변하는 로직이 있을 때 책임을 어떻게 할당해야 할까?
- 해결 → 타입을 명시적으로 정의하고, 각 타입에 다형적으로 행동하는 책임을 할당하라
- 객체의 종류에 따라 분기하는 조건문을 사용하지 말고 다형성을 사용하는 것이 좋은 방법이다.

### 변경 보호 패턴(Protected Variations)

- 문제 → 어떻게 하면 변화가 다른 요소에 영향을 미치지 않도록 방지할 수 있을까?
- 해결 → 변화가 예상되는 지점을 식별하고, 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라
- 변경을 캡슐화하고 책임을 할당한다.
    - 영화 클래스는 할인 조건 인터페이스가 있기에 다른 할인 조건이 추가되더라도 영향을 받지 않는다.
    - 할인 조건 인터페이스의 구현체를 추가하는 것 만으로도 할인 조건의 종류를 확장할 수 있다.

### 컨트롤러 패턴(Controller)

- 문제 → 시스템 요청을 받아야 하는 객체는 무엇인가?
- 해결 → 사용자의 요청을 처리하는 Controller 객체를 만들어서 사용해야 한다.
- Web MVC의 Controller가 좋은 예시라고 생각하겠지만 아니라고 한다.
    
    > At first glance, it would seem that the MVC Controller in Web applications/API’s is a great example here (even the name is the same) but for me it is not true.
    - Kamil Grzybek
    > 
- 어떤 서브시스템이 존재한다고 가정.
    - 직접적으로 객체에 접근하여 프로그램을 사용한다면 결합도가 상승한다.
    - 서브 시스템에 들어오는 요청을 처리해주는 컨트롤러가 있다면 사용하는 입장에서는 해당 컨트롤러만 알면 된다.
    - 만약 서브 시스템의 변경이 생겼을 때 외부에 미치는 영향도 줄어든다.

### 간접 참조 패턴(Indirection)

- 문제 → 두 객체 사이의 직접적인 연결을 피하고 싶다면?
- 해결 → 두 객체 사이에 또 다른 객체를 두어 직접적인 연결을 피해라
- 중간에 인터페이스를 둘 수도 있고, 중재자 패턴을 사용하여 두 객체 사이에 또 하나의 객체를 추가하여 복잡한 관계를 단순화할 수 있다.

### 순수한 가공물 패턴(Pure Fabrication, p.292)

- 문제 → 책임을 할당한 도메인 객체가 Low Coupling, High Cohesion, 재사용성 등의 목적을 위반한다면 어떻게 해야하나?
- 해결 → 도메인 개념을 포함하지 않는 클래스를 하나 만들고 매우 응집된 책임을 할당하라
- 행동을 추가할 때, 행동을 책임질 마땅한 도메인 개념이 존재하지 않는 다면 도메인과 무관한 인공적인 객체를 만든다음 해당 객체에게 책임을 할당한는 것이다.
- 객체가 데이터베이스에 저장해야 될 값을 가지고 있다고 정보 전문가 패턴을 적용하여 데이터베이스에 저장하라는 책임을 가지라고 하지 않는다.
- 예) 상점과 고객 클래스가 있고 서로 다른 통화를 사용하고 있다고 가정
    - 서로 다른 통화를 사용하고 있기 때문에 거래를 하려면 환전을 해야한다.
    - 두 클래스 다 환전에 대한 책임을 부여하기 애매하다면 환전을 책임하는 클래스를 추가하고 사용할 수 있다.

### 참고 자료

- [GRASP, 한빛 네트워크](https://www.hanbit.co.kr/network/category/category_view.html?cms_code=CMS8586826397)
- [GRASP, Kamil Grzybek](http://www.kamilgrzybek.com/design/grasp-explained/)