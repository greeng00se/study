> 오브젝트를 읽고 정리한 글입니다.
> 

### 개요

- 의존성을 관리하여 결합도를 낮추는 방법을 알아보자

### 의존성

- 서로 다른 객체가 협력하는 경우 두 객체 사이에 의존성이 존재하게 된다.
- 의존성은 변경에 의한 영향의 전파 가능성을 암시한다.
- 의존성은 실행 시점과 구현 시점의 의존성으로 나뉜다.
    - 실행 시점 → 의존하는 객체가 정상적으로 동작하기 위해서 실행 시 의존 대상 객체가 존재해야 한다.
    - 구현 시점 → 의존 대상 객체가 변경되는 경우, 의존하는 객체도 함께 변경된다.

### 의존성을 관리하는데 알아야하는 개념

- 의존성 전이 → 변경에 의한 영향이 널리 전파될 수 있다는 것
    - 직접 의존성 → 직접 의존하는 경우
    - 간접 의존성 → 직접적인 관계는 존재하지 않지만 영향이 전파되는 경우
- 런타임 의존성과 컴파일 타임 의존성
    - 런타임 의존성 → 객체 사이의 의존성
    - 컴파일 타임 의존성 → 클래스 사이의 의존성
- 컨텍스트 독립성
    - 특정한 문맥에 대해 최소한의 가정으로 이루어져있을 때 다른 문맥에서 재사용하기가 수월해지는 것
    - 각 객체가 해당 객체를 실행하는 시스템에 관해 알지 못해야 재사용될 수 있다.
- 의존성 해결
    - 컴파일 타임의 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것
    - 의존성 해결 방법 → 생성자, 생성 후 setter 메서드 사용, 메서드 실행 시 인자 사용

### 의존성과 결합도

- 의존성이 과해 바람직하지 못한 경우 결합도가 강하다라고 표현한다.
    - 서로에 대해 알고 있는 지식의 양이 결합도를 결정한다.
- 결합도를 낮추기 위한 방법에는 어떤 것들이 있을까?

### 추상화

- 결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 알아야 하는 지식의 양을 줄여야 한다.
- 추상화는 세부사항, 구조에 대한 이해를 돕기 위해 특정 절차를 생략하거나 감춤으로 복잡도를 관리하는 방법이다.
- 구체 클래스 > 추상 클래스 > 인터페이스
    - 대상이 더욱 추상적일수록 결합도는 낮아진다.

### 명시적인 의존성(explicit dependency)

```java
public class Movie {
    private DiscountPolicy discountPolicy;
    
    public Movie() {
        this.discountPolicy = new AmountDiscountPolicy(...);
    }
}
```

- 위 코드에서는 `Movie` 클래스가 `DiscountPolicy`에 의존한다는 사실을 감추고 있다.
    - 의존성이 퍼블릭 인터페이스에 표현되지 않는다. 이를 숨겨진 의존성(hidden dependency)이라고 한다.

```java
public class Movie {
    private DiscountPolicy discountPolicy;
    
    public Movie(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

- 의존성을 명시적으로 퍼블릭 인터페이스에 노출하는 것으로 명시적인 의존성이라고 한다.
- 의존성이 명시적이지 않으면?
    - 의존성을 파악하기 위해 내부 구현을 살펴봐야 한다.
    - 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 한다.
- 의존성은 협력을 위해 필요하다. 의존성을 감추지 말고 드러내야 한다.

### new는 해롭다.

- `new` 키워드를 사용하여 클래스 안에서 객체의 인스턴스를 직접 생성한다면 클래스 사이의 결합도가 극단적으로 높아진다.
- 구체 클래스를 생성하기 위한 정보, 정보의 순서도 알아야 하기 때문에 결합도가 높아질 수 밖에 없다.
- 사용과 생성의 책임을 분리하여 문제를 해결할 수 있다.
    - 외부에서 이미 생성된 인스턴스를 전달 받아 사용하는 것이다.

### 가끔은 생성해도 무방하다.

- 클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있다.

```java
public class Movie {
    private DiscountPolicy discountPolicy;

    public Movie() {
        this(new AmountDiscountPolicy(...));
    }
    
    public Movie(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}
```

- 협력하는 기본 객체를 설정하고 싶을 때 사용할 수 있다.
- 이는 클래스의 사용성을 향상시키고 다양한 컨텍스트에서 유연하게 사용될 수 있다.
- 결합도와 사용성의 트레이드오프다.
    - 구체 클래스에 의존하더라도 사용성이 중요하다면 위와 같이 사용할 수 있다.
    - 결합도가 모이는 새로운 클래스를 추가하여 사용성과 유연성을 잡을 수도 있다. Factory

### 표준 클래스에 대한 의존은 해롭지않다.

- 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다.
- 대표적인 예시로 JDK의 표준 컬렉션 라이브러리에 속하는 `ArrayList`같은 경우 직접 생성해서 대입하는 것이 일반적이다.

```java
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions = new ArrayList<>();

    public void switchConditions(List<DiscountCondition> conditions) {
        this.conditions = conditions;
    }
}
```

- 위와 같이 클래스를 직접 생성하더라도 추상적인 타입을 사용하면 설계의 유연성을 높힐 수 있다.

### 정리

- 유연하고 재사용 가능한 설계는 객체들의 조합을 통해 무엇을 하는지 표현하는 클래스로 구성된다.
- 작은 객체들의 행동을 조합 → 새로운 행동
- 이러한 설계를 창조하는 데 있어서 핵심은 의존성을 관리하는 것이다.