> 토비의 스프링 3.1을 읽고 정리한 글입니다.
>

## 2. 테스트

### 목표

- 테스트란 무엇인가?
- 테스트의 장점, 활용 전략, 스프링과의 관계

> 📌  테스트(Test)
> 
> - 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지 확인하는 것
> - 동작을 통해 코드를 확신할 수 있게 하는 작업

## 2.1 UserDaoTest 다시보기

### 작은 단위의 테스트

- 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다.(관심사의 분리 원리 적용)

> 📌  단위 테스트(Unit Test)
> 
> - 작은 단위의 코드에 대해 테스트를 수행하는 것
> - 단위 테스트를 하는 이유?
>     - 설계하고 만든 코드가 원래 의도대로 동작하는지 확인(빠른 피드백)

### 자동수행 테스트 코드

- 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.
- 자동수행 → 반복가능으로 이어진다.

### 지속적인 개선과 점진적인 개발을 위한 테스트

- 테스트로 검증해서 코드에 대한 확신을 가지고, 그 후에 기능을 추가하는 식으로 점진적인 개발이 가능해진다.

## 2.2 UserDaoTest 개선

### 테스트의 효율적인 수행과 결과 관리

- JUnit 프레임워크를 이용해서 테스트를 효율적으로 진행 할 수 있다.
- JUnit의 요구조건
    - 테스트하려는 메소드가 public으로 선언되어 있어야 한다.(JUnit5 부터는 없어도 된다)
    - `@Test` 애노테이션을 붙여야 한다.

### JUnit의 테스트 메소드가 public이어야 했던 이유 - 토비님 글

![image](https://user-images.githubusercontent.com/58586537/168466553-d54199bb-67ae-4226-8134-21a7bc26df2a.png)

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit

### 동일한 결과를 보장하는 테스트

- 항상 일관성 있는 결과가 보장돼야 한다.
- DB에 남아있는 데이터와 같은 외부 환경에 영향을 받지 말아야 한다.
- 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되어야 한다.

### 포괄적인 테스트

- 다양한 상황과 입력 값을 고려하는 포괄적인 테스트를 만드는 것이 좋다.
- 테스트를 작성할 때는 부정적인 케이스를 먼저 만드는 습관이 좋다.
    - ex) 존재하지 않는 id를 가져올 때
    

### 기능설계를 위한 테스트

- 테스트 코드는 잘 작성된 하나의 기능정의서와 비슷해보인다.
    - 책에서는 조건, 행위, 결과로 나누어져있다.
    - Given-When-Then 패턴
- 기능 설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당 하는 부분을 테스트 코드가 담당한다.
- 추가하고 싶은 기능을 테스트 코드로 표현 → 실제 기능을 가진 코드 입력
    - 설계한대로 동작하는지 빠른 검증이 가능하다.

### 테스트 주도 개발

> 📌  테스트 주도 개발(TDD, Test Driven Development)
> 
> - 만들고자 하는 기능의 내용을 담고 있고, 코드의 검증을 할 수 있는 테스트 코드를 먼저 만들고 테스트를 성공하게 해주는 코드를 작성하는 개발 방법론
> - 기본 원칙
>     - 실패한 테스트를 성공시키기 위한 목적이 아닌 코드를 만들지 않는다.
- TDD에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 짧게 가져가도록 권장한다.
    - 길어야 10분 내외

### JUnit의 테스트 수행 방식

1. 반환값과 파라미터가 없고, `@Test`가 붙은 테스트 메소드를 찾는다.
2. 테스트 클래스의 오브젝트를 만든다.
3. `@Before`가 붙은 메소드 존재 시 실행
4. `@Test`가 붙은 메소드 호출하고 테스트 결과 저장
5. `@After`가 붙은 메소드 존재시 실행
6. 2~5번 반복
7. 테스트 결과를 종합하여 돌려준다.

## 2.4 스프링 테스트 적용

### 테스트 메소드의 컨텍스트 공유

- `@ExtendWith`
    - JUnit4에서는 `@RunWith(SpringJUnit4ClassRunner.class)` 으로 사용한다.
        - JUnit의 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애노테이션이다.
- `@ContextConfiguration`
    - 자동으로 만들어줄 애플리케이션 컨텍스트의 설정 위치를 지정한 것이다.
- 애플리케이션 컨텍스트 테스트 개수에 상관없이 한 번만 만들어서 공유한다.
    - 테스트 수행 속도의 증가
    - 재사용성

### DI와 테스트

- 테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 것이 좋다.
- DI를 주입받을 때는 인터페이스를 두고 DI를 적용하는 것이 좋다.
    - 클래스의 구현 방식은 바뀌지 않아도 인터페이스를 두고 DI를 적용하게 하면 다른 차원의 서비스 기능을 도입할 수 있다.

## 2.5 학습 테스트로 배우는 스프링

> 📌  학습 테스트(learning test)
> 
> - 자신이 만들지 않은 프레임워크나 라이브러리 등에 대해서 테스트를 하는 것
> - API나 프레임워크의 기능을 테스트로 보면서 사용방법을 익히는 것

### 학습 테스트의 장점

- 다양한 조건에 따른 기능을 손쉽게 확인해 볼 수 있다.
- 학습 테스트 코드를 개발 중에 참고할 수 있다.
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
- 테스트 작성에 대한 훈련이 된다.
- 조금 더 흥미롭게 기술을 익힐 수 있다.

### 버그 테스트

> 📌  버그 테스트(bug test)
> 
> - 오류가 있을 때 오류를 가장 잘 드러내줄 수 있는 테스트
> - 기능 오류가 발생했을 때 해당 오류가 원인이 되서 테스트가 실패하는 코드를 만드는 것
- 버그 테스트의 장점
    - 테스트의 완성도를 높여준다.
    - 버그의 내용을 명확하게 분석하게 해준다.
    - 기술적인 문제를 해결하는데 도움이 된다.

### 동등 분할과 경계값 분석

- 동등 분할(equivalence partitioning)
    - 같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트를 하는 방법
    - ex) true, false, 예외발생 세가지 일 경우 각 결과를 내는 입력 값과 상황의 조합을 만든 후 모든 경우에 대한 테스트 실행
- 경계값 분석(boundary value analysis)
    - 경계의 근처에 있는 값을 이용해 테스트 하는 방법
    - ex) 0, 최소 값, 최대 값
