**동일성과 동등성**
동일성은 메모리의 주소값이 같은지 비교하는 것이다. → 동등 비교연산자를 이용하여 두 인스턴스가 완전히 동일한 경우를 확인
동등성은 논리적으로 일치하는지 비교하는 것이다. → 논리적인 기준을 equals & hashcode를 통해 구현 후 비교

**EnumMap**
Enum타입의 키를 받는 Map의 구현체이다. 
Enum 타입의 상수 개수만큼 저장공간을 확보하면 되기 때문에 리사이징이 필요없고, 해시를 이용하지 않아도 되기 때문에 HashMap 대비 성능이 좋다.

**Stack vs Deque**
Stack: LIFO(Last In First Out) 자료 구조
Deque: Queue 인터페이스를 구현한 자료 구조로 양 끝단에서 자료를 추가하거나, 삭제할 수 있다.
Deque의 구현체로는 LinkedList와 ArrayDeque가 있다.

**Stack은 왜 사용하면 안될까?**
Stack은 Vector를 상속받은 구현체기 때문에 Vector가 가지고 있는 문제를 그대로 가지고 있다.
1. 초기 용량 설정을 지원하지 않는다.
2. 모든 작업에 Lock이 사용되기 때문에 단일 스레드에서 사용할 때도 성능 저하가 일어날 수 있다.

**try-with-resources와 사용시 장점**
자바 7 부터 사용이 가능하고, 사용하려는 자원이 `AutoCloseable` 인터페이스를 구현해야 한다.
try 구문 안에 자원을 선언하고, try 구문이 종료되는 경우 자동으로 생성의 역순으로 반납을 해주는 기능이다.
finally에서 close와 비교시 try-with-resources의 장점
- 코드의 가독성이 좋아진다.
- 일일히 자원에 대한 반납 작업을 하지 않아도 된다.
- 개발자의 실수나, 에러로 인해 자원을 반납하지 못하는 경우를 방지할 수 있다.
- 에러에 대한 스택 트레이스를 남길 수 있다.

**equals와 hashcode를 함께 정의해야 하는 이유?**
hashCode를 재정의를 하지 않는 경우 Object의 기본 hashCode 메서드를 사용하게 된다.
따라서 논리적으로 같다고 하더라도 hashcode 메서드가 다른 값을 반환하기 때문에, hash를 사용하는 Collection 구현체를 사용할 때 문제가 발생한다.

**제어할 수 없는 부분에 대한 테스트**
테스트 대상이 검증된 것이라면 작성하지 않거나, 제어할 수 있는 부분에 대한 테스트를 더욱 꼼꼼하게 작성한다.
개인적인 의견: 안정감이 들 수 있을 정도로 출력 범위 내의 결과를 반환하는지 정도 테스트할 수 있지 않을까?

**객체의 생성 책임**
다음의 요소를 최대한 만족하는 클래스B에 A의 생성 책임을 할당하는 것이 좋다.
- B가 A 객체를 포함 또는 참조한다.
- B가 A 객체를 기록한다.
- B가 A를 긴밀하게 사용한다.
- B가 A의 초깃값을 가지고 있다.

**사용하는 쪽에서 생각하기 & 예측가능한 코드 작성하기**
해당 클래스를 사용하는 쪽에서 생각하고, 메서드명을 보고 어떤 동작을 하는지 유추할 수 있도록 코드를 작성한다.
어떠한 기능에 대한 메서드가 있다면, 최대한 해당하는 부분만 동작되도록(side effect가 일어나지 않도록) 작성을 한다.

**상태 패턴의 적용 기준**
상태에 따라 동작이 달라지는 경우(if, else와 같은 분기문을 효과적으로 처리할 수 있을 것 같을 때)적용할 수 있다.