> Real MySQL 8.0을 읽고 정리한 글입니다.
> 

## 인덱스

- 칼럼의 값과 해당 레코드가 저장된 주소를 `key-value` 형태로 만들어 일종의 목차를 만드는 것이다.
- 데이터의 저장 (`INSERT`, `UPDATE`, `DELETE`) 성능이 줄어들지만 조희(`SELECT`)의 성능을 향상시킨다.

```sql
-- 인덱스 조회
SHOW INDEX FROM table_name;

-- 인덱스 생성
CREATE INDEX index_key_name ON table_name (column_name);
ALTER TABLE table_name ADD INDEX index_key_name (column_name);

-- 인덱스 삭제
ALTER TABLE table_name DROP INDEX idx_pname;

-- 실제로 인덱스가 사용되는지 확인 (Type -> All & possible_keys	-> NULL 이면 사용되지 않는 것)
EXPLAIN
select * from table_name
where column_name = '조회할 것';
```

## B-Tree

- B-Tree는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되는 알고리즘이다.
- 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지한다.
- 루트 노드 - 브랜치 노드 - 리프 노드로 구성되어있고, 리프노드가 모두 같은 레벨에 존재하는 Balanced-Tree이다.

- MyISAM의 테이블은 세컨더리 인덱스가 물리적인 주소를 가진다.
    - 데이터 파일에 바로 접근한다.
- InnoDB의 테이블은 세컨더리 인덱스가 논리적인 주소를 가지고 있다.
    - PK에 대한 인덱스를 통해 다시 한 번 더 검색한다.

## B-Tree 인덱스 키 추가 및 삭제

- 인덱스 키 추가
    - 스토리지 엔진에 따라 키 값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다.
    - 일반적으로 인덱스에 키를 추가하는 작업비용은 인덱스 당 1.5로 예측한다. (테이블 레코드 추가 1 기준)
        - 인덱스가 3개 존재한다면 5.5(1.5 * 3 + 1) 정도로 예측한다.
- 인덱스 키 삭제
    - 해당 키 값이 저장된 리프 노드를 찾아 삭제 마크를 하면 작업이 완료된다.
    - 해당 인덱스 키 공간은 방치되거나 재활용할 수 있다.
- 인덱스 키 변경
    - B-Tree의 키 값 변경은 단순 수정이 아니라 키 값을 삭제하고 추가하는 형태로 처리된다.
- 인덱스 키 검색
    - 루트 노드 - 브랜치 노드 - 리프노드까지 이동하면서 비교작업을 수행하고 이걸 트리탐색이라 한다.
    

## B-Tree 인덱스 사용에 영향을 미치는 요소

- 인덱스를 구성하는 칼럼의 크기와 레코드의 건수, 유니크한 인덱스 키 값의 개수에따라 성능이 달라진다.

### 인덱스 키 값의 크기

- InnoDb 스토리지 엔진의 디스크에 데이터를 저장하는 기본 단위를 페이지 또는 블록이라고 한다.
- `inndb_page_size` 시스템 변수에 등록된 기본 페이지의 크기는 16KB이다.
- 자식 노드 주소가 12바이트라고 가정 할 때
    - 키의 크기가 16바이트 → 500개 가량의 키를 저장할 수 있다.
    - 키의 크기가 32바이트 → 300개 가량의 키를 저장할 수 있다.
- 만약 `SELECT` 쿼리가 500개의 레코드를 읽어야할 때 키의 크기가 16바이트 일때는 1개의 페이지만 읽으면 되지만, 32바이트가 된다면 2개의 페이지를 읽어야한다.
- 인덱스를 구성하는 키 값의 크기가 커진다면 디스크로부터 읽어야하는 횟수가 늘어나고 느려진다.

### B-Tree의 깊이

- 갚은 레코드 건수라도 인덱스의 키값이 커진다면 B-Tree의 깊이가 깊어지기 때문에 읽기에 더 많은 시간이 필요하다.
- B-Tree의 깊이가 3인경우
    - 키 값이 16바이트 → 2억개(585 * 585 * 585) 정도의 키 값을 담을 수 있다.
    - 키 값이 32바이트 →  5천만개(372 * 372 * 372) 정도의 키 값을 담을 수 있다.
- 실제로 아무리 대용량 데이터베이스라도 깊이가 5단계 이상으로 가는 경우는 흔치 않다.

### 선택도(Selectivity), 기수성(Cardinality)

- 인덱스의 키 값 가운데 유니크한 값의 수를 의미한다.
    - 예) 전체의 키 값이 100개일 때 유니크한 값의 수가 10개라면 기수성은 10이다.
- 인덱스 키 값 중 중복된 값이 많아지면(유니크한 값이 줄어든다면) 기수성은 낮아지고 선택도 또한 떨어진다.
- 선택도가 높을수록 검색 대상이 줄기 때문에 빠르게 처리된다.

```sql
CREATE TABLE table_city(
  country VARACHAR(10)
  city VARCHAR(10),
  INDEX ix_country (country)
);

SELECT *
FROM table_city
WHERE country='KOREA' AND city='SEOUL';

-- 예) 10000개의 데이터 중 country 칼럼의 유니크 값이 10개인 경우
-- KOREA로 검색할 때 1000건 일치하고 그 가운데 SEOUL인 레코드는 1건이므로 999건이 버려진다.

-- 예) 10000개의 데이터 중 country 칼럼의 유니크 값이 1000개인 경우
-- KOREA로 검색할 때 10건이 일치하고 극 가운데 SEOUL인 레코드가 1건이므로 9건이 버려진다.
```

### 읽어야하는 레코드의 건수

- 인덱스를 통해 레코드를 읽는것은 테이블의 레코드를 그냥 읽는 것보다 높은 비용이 든다.
- 테이블에 레코드가 100만건 있는 경우 50만 건을 읽어야하는 쿼리가 있을 때 옵티마이저가 인덱스를 통해 읽는 것과 직접 읽는 것 어느쪽이 효율적일지 어떻게 판단할까?
- 옵티마이저는 보통 인덱스를 통해서 1건을 읽는 건 직접 레코드 1건을 읽는 것보다 4~5배 비용이 많이 드는 작업으로 예측한다.
- 그래서 보통 20%~25% 이상의 레코드를 읽는 경우 힌트를 통해 강제로 인덱스를 사용하도록 해도 옵티마이저가 이를 무시하고 직접 테이블을 읽어 처리한다.

## B-Tree 인덱스를 통한 데이터 읽기

- 어떤 경우에 인덱스를 사용하게 유도할지, 사용하지 못하게 할지 판단하려면 어떻게 인덱스를 이용해서 실제 레코드를 일는지 알아야 한다.
- MySQL이 인덱스를 이용하는 대표적인 방법을 알아보자

### 인덱스 레인지 스캔

- 리프노드에서 레코드의 시작 지점을 찾은 다음 리프노드의 레코드를 범위가 끝날 때 까지 순차적으로 읽는 방식이다.
    - 리프 노드의 끝까지 읽는 경우 리프노드 간 링크를 이용해 다음 리프노드를 찾아서 스캔한다.
- 가장 대표적인 방법으로 검색해야 할 인덱스의 범위가 결정됐을 때 사용하고 빠르다.

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색이라고 한다.
2. 1번에서 탐색된 위치에서 필요한 만큼 인덱스를 차례대로 쭉 읽는다.
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어온다.

### 인덱스 풀 스캔

- 인덱스를 처음부터 끝까지 모두 읽는 방식이다.
- 인덱스 레인지 스캔보다는 느리지만 테이블 풀 스캔보단 효율적이다.
- 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 사용된다.

1. 인덱스 탐색을 통해 리프 노드의 제일 앞으로 이동한다.
2. 해당 리프 노드부터 끝까지 스캔하는 방식이다.

### 루스 인덱스 스캔

- 전체 데이터를 읽는 방식이 아니라 스캔하는 과정 도중 필요없는 인덱스 키 값을 무시하는 방식이다.

```sql
// dept_no와 emp_no로 인덱스 생성이 되었다고 가정
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd0004'
GROUP BY dept_no;
```

- 위 `SELECT` 쿼리는 `MIN`을 구하기 때문에 `dept_no` 그룹 별로 첫 번째 레코드의 `emp_no`만 필요하다.

### 인덱스 스킵 스캔

- MySQL 8.0에 도입된 스캔으로 설정된 인덱스를 더욱 효율적으로 사용할 수 있는 스캔 방법이다.
- (A, B) 인덱스를 추가했을 때 옵티마이서가 `WHERE` 조건 절에 A가 없더라도 B만 이용해 스캔을 실행한다.
- 인덱스 스킵 스캔과 비슷한 루스 인덱스 스캔은 `GROUP BY` 작업을 처리하는 경우에만 처리할 수 있었지만 8.0이후 인덱스 스킵 스캔을 도입하고 난 후에는 `WHERE` 조건 절의 검색을 위해 아래와 같이 사용할 수 있다.

```sql
ALTER TABLE employees
ADD INDEX ix_gender_birthdate (gender, birth_date);

-- 인덱스를 사용할 수 있는 쿼리
SELECT * FROM employees WHERE gender='M' AND birth_date>='1965-02-01';

-- MySQL 8.0 이전에는 인덱스 풀 스캔을 사용하여 처음부터 끝까지 읽는다.
-- MySQL 8.0 이후에 인덱스 스킵 스킨을 이용해서 gender가 없더라도 다음과 같이 스캔이 가능하다.
-- 1. 성별 M 기준 '1965-02-01' 이후 인덱스 레인지 스캔
-- 2. 성별 W 기준 '1965-02-01' 이후 인덱스 레인지 스캔
SELECT * FROM employees WHERE birth_date>='1965-02-01';
```

- 하지만 다음과 같은 단점도 있다.
    - `WHERE` 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 한다.
    - 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 한다(커버링 인덱스)
    

## 다중 칼럼 인덱스

- 실제 서비스용 데이터베이스에서는 2개 이상의 칼럼을 사용하는 인덱스가 더 많이 사용된다.
- 두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스(복합 칼럼 인덱스)라고 한다.
- 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬이되기 대문에 다중 칼럼 인덱스에서는 각 칼럼의 위치가 중요하며 신중히 결정해야 한다.

## B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스를 생성할 대 설정한 정렬 규칙에 따라서 인덱스의 키 값은 오름차순이거나 내림차순으로 정렬되어 저장된다.

### 인덱스의 정렬

- MySQL 5.7까지는 칼럼 단위로 정렬 순서를 정할 수 없어서 -1 를 곱하는 우회 방법을 사용했었다.
- MySQL 8.0 이후부터는 다음과 같이 순서를 혼합하여 인덱스를 생성할 수 있다.

```sql
CREATE INDEX ix_teamname_userscore 
ON employees (team_name ASC, user_score DESC);
```

### 인덱스 스캔 방향

- 인덱스 생성 시점에 오름차순과 내림차순으로 정렬이 결정이된다.
    - 오름차순 인덱스: 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
    - 내림차순 인덱스: 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
- 인덱스를 사용하는 시점에 읽는 방향에 따라 오름차순, 내림차순 정렬 효과를 얻을 수 있다.
    - 인덱스 정순 스캔:  인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
    - 인덱스 역순 스캔:  인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔
- InnoDB에서는 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느리다.
    - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조기 때문이다.
    - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조기 때문이다.
- 많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 특정 페이지 잠금이 병목이 될 것으로 예상된다면, 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 병목 현상을 완화하는데 도움이 된다.

## B-Tree 인덱스의 가용성과 효율성

### 비교 조건의 종류와 효율성

- 다중 칼럼 인덱스에서 각 칼럼의 순서나, 조건에 따라 인덱스 칼럼의 활용 형태가 달라진다.

```sql
-- 조건에 맞는 레코드가 5개 있다고 가정
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no >= 10114;

-- Case A dept_no가 d002 중 emp_no가 10114보다 큰 레코드인지 확인한다.
INDEX(dept_no, emp_no)
-- Case B emp_no가 10114보다 큰 모든 레코드에 대해 dept_no가 d002인지 확인한다.
INDEX(emp_no, dept_no)
```

- CaseA와 같이 작업 범위를 줄여주는 것을 작업 범위 결정 조건이라고 한다.
- CaseB와 같이 작업 범위를 줄여주지는 않고 단순 거름종이 역할만 하는 조건을 필터링 조건이라고 한다.

### 인덱스의 가용성

- B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬되있다는 것이다.

```sql
SELECT * FROM employees WHERE first_name LIKE '%mer';
```

- 따라서 위와 같은 쿼리는 왼쪽 값이 고정되어있지 않기 때문에 인덱스를 활용할 수 없다.

```sql
-- INDEX (dept_no, emp_no)
SELECT * FROM dept_emp WHERE emp_no>=10144;
```

- 위와 같은 경우에도 dept_no 조건이 없기 때문에 인덱스 스킵 스캔을 사용하더라도 효율적으로 사용할 수 없다.

### 인덱스를 사용할 수 없는 경우

- `NOT-EQUAL`로 비교된 경우 (`<>, NOT IN, NOT BETWEEN, IS NOT NULL`)
- `LIKE ‘%??’` (뒷 부분 일치) 형태로 문자열 패턴이 비교된 경우
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
- 인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우(데이터 타입이 다른 비교)
- `NOT-DETERMINISTIC` 속성의 스토어드 함수가 비교 조건에 사용된 경우
- 문자열 데이터 타입의 콜레이션이 아닌 경우